# Question: (Hard)

(This problem is the same as Minimize Malware Spread, with the differences bolded.)

In a network of nodes, each node i is directly connected to another node j if and only if graph[i][j] = 1.

Some nodes initial are initially infected by malware.  Whenever two nodes are directly connected and at least one of those two nodes is infected by malware, both nodes will be infected by malware.  This spread of malware will continue until no more nodes can be infected in this manner.

Suppose M(initial) is the final number of nodes infected with malware in the entire network, after the spread of malware stops.

We will remove one node from the initial list, completely removing it and any connections from this node to any other node.  Return the node that if removed, would minimize M(initial).  If multiple nodes could be removed to minimize M(initial), return such a node with the smallest index.

## Example 1:

>Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]  <br>
>Output: 0 <br>

## Example 2:

>Input: graph = [[1,1,0],[1,1,1],[0,1,1]], initial = [0,1] <br>
>Output: 1 <br>

## Example 3:

>Input: graph = [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]], initial = [0,1] <br>
>Output: 1 <br>
 
## Note:

* 1 < graph.length = graph[0].length <= 300
* 0 <= graph[i][j] == graph[j][i] <= 1
* graph[i][i] = 1
* 1 <= initial.length < graph.length
* 0 <= initial[i] < graph.length

# 解析：本题大意为：病毒在节点中传播，若可以删去一个节点使最终感染病毒的节点最少，应该删去哪个节点。

病毒的传播使用图的dfs遍历。思路很简单，每次去掉一个节点，算出最终感染节点的个数。每次删除一个节点不能在原graph修改，应引入tempgraph，也引入tempinit代表初始感染节点。生成tempinit时由于真正删除元素费时，可以把要删除的元素赋成-1。此时要注意tempinit的值当做数组下标时，注意越界情况。

# 注：

1. oj出现了runtime error: Double free or corruption(out), 在本地却未出现该错误, 最终发现原因为数组越界。即FinalInfected 函数中 initial 有-1值，若未判断 visit[initial[i]] 导致越界。

2. 二维数组也可以使用 = 来赋值。